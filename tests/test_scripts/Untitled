streams = '/tmp/output_desikan_det_local_csd_native_dsn/dwi/fiber/streamlines.trk'
fa_path = '/tmp/output_desikan_det_local_csd_native_dsn/dwi/preproc/tensor_fa.nii.gz'
nodif_B0 = '/tmp/output_desikan_det_local_csd_native_dsn/dwi/preproc/nodif_B0_bet.nii.gz'
nodif_B0_mask = '/tmp/output_desikan_det_local_csd_native_dsn/dwi/preproc/nodif_B0_bet_mask.nii.gz'

reg = mgr.dmri_reg(namer, nodif_B0, nodif_B0_mask, t1w, vox_size, simple=False)


g1 = graph_tools(
    attr=len(np.unique(labels_im.get_data().astype("int"))) - 1,
    rois=labels_im_file_mni,
    tracks=streamlines_mni,
    affine=np.eye(4),
    namer=namer,
    connectome_path=connectomes[idx],
)

def make_graph(self, overlap_thr=1, voxel_size=2, attr=None):
    """
    Takes streamlines and produces a graph
    **Positional Arguments:**
            streamlines:
                - Fiber streamlines either file or array in a dipy EuDX
                  or compatible format.
    """
    print("Building connectivity matrix...")

    # Instantiate empty networkX graph object & dictionary
    # Create voxel-affine mapping
    lin_T, offset = _mapping_to_voxel(np.eye(4), voxel_size)
    mx = len(np.unique(g1.rois.astype(np.int64)))
    g1.g = nx.Graph(ecount=0, vcount=mx)
    edge_dict = defaultdict(int)
    node_dict = dict(zip(np.unique(g1.rois), np.arange(mx)))

    # Add empty vertices
    for node in range(mx):
        g1.g.add_node(node)

    ix = 0
    for s in g1.tracks:
        # Map the streamlines coordinates to voxel coordinates
        points = _to_voxel_coordinates(s, lin_T, offset)

        # get labels for label_volume
        i, j, k = points.T
        lab_arr = g1.rois[i, j, k]
        endlabels = []
        for lab in np.unique(lab_arr):
            if lab > 0:
                if np.sum(lab_arr == lab) >= overlap_thr:
                    endlabels.append(node_dict[lab])

        edges = combinations(endlabels, 2)
        for edge in edges:
            lst = tuple([int(node) for node in edge])
            edge_dict[tuple(sorted(lst))] += 1

        edge_list = [(k[0], k[1], v) for k, v in edge_dict.items()]

        g1.g.add_weighted_edges_from(edge_list)
        ix = ix + 1

    return g1.g



template_path = '/tmp/output_desikan_det_local_csd_native_dsn/tmp/reg_a/desikan_space-MNI152NLin6_res-2x2x2_reor_RAS_nores_aligned_atlas_t1w_mni.nii.gz'
